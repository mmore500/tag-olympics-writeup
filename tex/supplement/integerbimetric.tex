\subsection{Bidirectional Integer Metric} \label{sec:integerbimetric}

Each tag was represented as an ordered, fixed-length bitstring,
\begin{align*}
t = \langle t_0, t_1, t_2, \dots, t_{n-2}, t_{n-1} \rangle
\end{align*}
where
\begin{align*}
\forall i, t_i \in \{0, 1\}.
\end{align*}

This metric is inspired by \citep{spector2011tag}.
They used positive integers between 0 and 100 to name referents.
Queries were provided the referent that had the next-larger value, wrapping around from 100 back to 0.

The bidirectional integer metric's inclusion explores the implications of relaxing the requirement to match to a next-larger operand.
Unlike the integer metric, this metric does not penalize operands with integer values smaller than the query.
Instead, queries match with the operands with respect to the absolute value of the difference of their integer representations.

In this metric, we compare tags according to their value as an unsigned integer according to the following representation $f$,
\begin{align*}
f(t)
= \sum_{i=0}^{n-1} t_i \times 2^i.
\end{align*}

The bidirectional integer distance metric $I$ between two length-$n$ tags $t$ and $u$ is
\begin{align*}
I(t, u) =
\begin{cases}
  \frac{f(t) - f(u)}{2^n}, & \text{if } f(t) > f(u), \\
  \frac{f(u) - f(t)}{2^n}, & \text{else} f(t) \leq f(u).
\end{cases}
\end{align*}

The division by $2^n$ is performed to ensure a match distance between 0 and 1.

Note that this metric is commutative and one-dimensional.
