\section{Methods}

In all experiments, we used ordered, fixed-length, 32-bit bitstrings as tags.
In experiments where mutations are applied to tags, individual bits are toggled stochastically with uniform per-bit probability.

We call an algorithm used to calculate the match quality between two tags a tag-matching metric.
A tag-matching metric takes two tags as operands and calculates a match distance between them.
We compared five tag-matching metrics, described below.
Full mathematical definitions and implementation details appear in Supplementary Material \citep{Moreno_Ofria_2020}.

\begin{itemize}
  \item \textbf{Hamming Metric}: calculates match distance according to the number of mismatching bits between tags \citep{lalejini2019else, hamming1950error}; Supplementary Section \ref{sec:hammingmetric}.
  \item \textbf{Hash Metric}: calculates a deterministic, but arbitrary, match distance between using the SHA1 cryptographic hash algorithm \citep{eastlake2001us}; Supplementary Section \ref{sec:hashmetric}.
  \item \textbf{Integer Metric}: match distance accumulates scanning upward from the unsigned integer representation of the first tag until the unsigned integer representation of the second tag is reached, wrapping around to zero if necessary \citep{spector2011tag}; Supplementary Section \ref{sec:integermetric}.
  \item \textbf{Bidirectional Integer Metric}: the lesser of integer metric distance calculated scanning upwards (still wraping around to zero) and integer metric distance calculated scanning downwards (wrapping around at zero); Supplementary Section \ref{sec:integerbimetric}.
  \item \textbf{Streak Metric}: match distance is calcualted as the ratio between the longest contiguously mismatching substring of two bitsets and the longest contiguously matching substring of those bitsets \citep{downing2015intelligence}; Supplementary Section \ref{sec:streakmetric}.\footnote{Our implementation of this metric differs slightly from its original form due to a mathematical error in \citep{downing2015intelligence}.}
\end{itemize}

% TODO give intuitions for each metric

For consistency of implementation and interpretation, we bound all metrics' tag-matching distances run between 0 (a perfect match) and 1 (a worst match).
We then normalized metrics' match distances so that match distances generated by pairs of randomly generated tags would follow a uniform distribution between 0 and 1.
This allows for an intuitive, consistent interpretation of match distances across all tag-matching metrics.
For example, two tags with a 0.01 match distance are better-matched than 99\% of randomly-generated tag pairs.
Additionally, in situations where raw match distance plays a mechanistic role (for example, probabilistic matching or threshold-based cutoffs), this transformation ensures consistency across metrics.

To accomplish this normalization to a uniform distribution, we sampled 10,000 randomly generated bitstring tag pairs to approximate metrics' raw distribution of match distances.
Then, for all further match distance calculations made using each metric, we calculated corrected distance for a raw distance $r$ as its percentile ranking among the initially-sampled match distances divided by one hundred.
If the exact raw distance $r$ wasn't present in the set of initially sampled match distance, we linearly interpolated between the next-greater and next-lower match distances' percentile rankings.
Supplementary Figure \ref{fig:uniformification} depicts the distributions of match distances between randomly sampled bitstring pairs for each metric before and after this normalization process.

\subsection{Implementation}

We implemented our experimental systems using the Empirical library for scientific software development in C++, available at \url{https://github.com/devosoft/Empirical} \citep{charles_ofria_2019_2575607}.
The code used to perform and analyze our experiments, our figures, and data from our experiments is available via the Open Science Framework at \url{https://osf.io/gw5mc/} \citep{foster2017open}.


